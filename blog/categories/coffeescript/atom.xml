<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: CoffeeScript | David's Blog]]></title>
  <link href="http://darkbaby123.github.com/blog/categories/coffeescript/atom.xml" rel="self"/>
  <link href="http://darkbaby123.github.com/"/>
  <updated>2013-03-16T21:08:15+08:00</updated>
  <id>http://darkbaby123.github.com/</id>
  <author>
    <name><![CDATA[David Chen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CoffeeScript支持source maps了，在浏览器中调试CoffeeScript已成为现实]]></title>
    <link href="http://darkbaby123.github.com/blog/2013/03/15/coffeescript-supports-source-maps-now/"/>
    <updated>2013-03-15T20:23:00+08:00</updated>
    <id>http://darkbaby123.github.com/blog/2013/03/15/coffeescript-supports-source-maps-now</id>
    <content type="html"><![CDATA[<p>CoffeeScript 1.6.1版本的新功能之一，就是支持source maps。</p>

<p>什么是source maps？简单的说，它可以通过一定的方式，从编译/压缩后的JavaScript代码，找到对应的未编译/压缩的源文件。</p>

<p>这个技术就是用来调试用的，目前可以用在两个地方：</p>

<ol>
<li>从压缩后的JavaScript代码找到未压缩的版本，让你在生产环境下调试时，不至于面对天书一样的JavaScript无从下手。</li>
<li>从编译后的JavaScript代码找到编译之前的CoffeeScript代码，不用你身体内置编译器了。</li>
</ol>


<p>我们可以建一个简单的项目试试，如果你不想动手的话，看看代码和图片也足够明白了。</p>

<!-- more -->


<h2>一个小实验</h2>

<p>需要环境：Node.js, npm, 已安装coffee-script包，Google Chrome最新版</p>

<p>先为项目建立一个文件夹叫aaa。里面包含两个文件，a.coffee和a.html，原谅我起的名字吧～</p>

<p><code>coffeescript a.coffee
window.hello = -&gt;
  console.log 'Hello World'
</code></p>

<p>```html a.html
&lt;!DOCTYPE html>
<html>
  <head></p>

<pre><code>&lt;script type="text/javascript" src="a.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </head>
  <body></body>
</html>
```</p>

<p>然后在aaa目录下，执行coffee命令编译a.coffee，带上参数 -m 用于生成source maps需要的文件。</p>

<p><code>bash Terminal
coffee -cm a.coffee
</code></p>

<p>这会生成两个文件，a.js和a.map，来看看这个两个文件：</p>

<p>```javascript a.js
//@ sourceMappingURL=a.map
// Generated by CoffeeScript 1.6.1
(function() {</p>

<p>  window.hello = function() {</p>

<pre><code>return console.log('Hello World');
</code></pre>

<p>  };</p>

<p>}).call(this);
```</p>

<p>```json a.map
{
  "version": 3,
  "file": "a.js",
  "sourceRoot": "",
  "sources": [</p>

<pre><code>"a.coffee"
</code></pre>

<p>  ],
  "names": [],
  "mappings": ";;AAAA;CAAA;CAAA,CAAA,CAAe,EAAf,CAAM,GAAS;CACL,EAAR,IAAO,IAAP,EAAA;CADF,EAAe;CAAf"
}
```</p>

<p>a.js自然是编译后的JavaScript文件，跟以前不同的是开头有两行注释。其中第一行就是告诉浏览器去找一个map文件 -- a.map。
浏览器就会通过a.map，把编译前后代的代码一一对应起来。a.map中的mappings内容就是记录这段内容的，它会根据a.coffee的改变而改变。
有兴趣的可以自行修改a.coffee尝试下。</p>

<p>项目到这里就搞完了。现在用浏览器实验下。</p>

<p>现在我们用Google Chrome打开a.html。再打开Inspector工具。先点击右下角的齿轮图标打开Settings，勾选Enable source maps。</p>

<p><img src="/images/blog/settings_source_maps.png"></p>

<p>然后关闭Settings，点击上面的Sources标签查看源代码，你会看到浏览器列出了a.coffee文件！</p>

<p><img src="/images/blog/sources_coffee.png"></p>

<p>现在我们先打个断点，然后执行hello函数看看：</p>

<p><img src="/images/blog/sources_coffee_debug.png"></p>

<p>See ?  It works !</p>

<h2>小结</h2>

<p>不难看出，要做到在浏览器中调试CoffeeScript代码，必须做到以下几点：</p>

<ol>
<li>浏览器支持source maps，目前我只知道Google Chrome支持，其他浏览器的情况未知。</li>
<li>JavaScript文件中提供关于map文件的信息。这需要CoffeeScript编译时加上 -m 参数。</li>
<li>浏览器可以通过url获取到coffee文件和map文件。</li>
</ol>


<p>也许因为这些原因，目前Rails项目里面还不能使用source maps直接调试CoffeeScript文件。好消息是Sprocket现在正在添加
对source maps功能的支持，应该不久就会有结果。到时候用Rails的我们就又high啦。</p>

<p>另外，source maps只是一个映射到源文件的技术，这就是说以后还可以利用这个技术在浏览器中看SASS和LESS，说不定还可以通过html看erb，slim和haml？前景可谓一片光明。</p>

<h2>参考文档</h2>

<ul>
<li><p><a href="http://coffeescript.org/#source-maps">CoffeeScript source maps</a><br/>
CoffeeScript官网的介绍。</p></li>
<li><p><a href="http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/">Introduction to JavaScript Source Maps</a><br/>
介绍source maps技术，想深挖原理的可以看看。里面有个demo，点击一段未压缩的JavaScript代码，可以看到该段代码对应源文件中的哪一行，非常cool。</p></li>
<li><p><a href="http://net.tutsplus.com/tutorials/tools-and-tips/source-maps-101/">nettuts+ Source Maps 101</a><br/>
这篇文章讲的很细，包括从压缩的JavaScript映射到未压缩的版本，从JavaScript映射到TypeScript（微软的预编译语言，更类似静态语言）等等。</p></li>
</ul>

]]></content>
  </entry>
  
</feed>
